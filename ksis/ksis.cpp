#include <iostream> // Подключение заголовочного файла для ввода/вывода.

using namespace std; // Используем пространство имен std.

// Функция для проверки корректности IP-адреса.
bool CheckAddress(char* ip_)
{
	int points = 0, // количество точек
	numbers = 0; // значение октета

	char* buff; // буфер для одного октета

	buff = new char[3]; // Выделение памяти для буфера.

	for (int i = 0; ip_[i] != '\0'; i++)
	{ // Для каждого символа в строке IP-адреса
		if (ip_[i] <= '9' && ip_[i] >= '0') // Если символ - цифра
		{
			if (numbers > 3) return false; // Если больше трех чисел в октете, то это ошибка.
			buff[numbers++] = ip_[i]; // Копируем символ в буфер.
		}
		else
			if (ip_[i] == '.') // Если символ - точка
			{
				if (atoi(buff) > 255)
					// Проверяем диапазон октета.
					return false;

				if (numbers == 0)
					// Если числа нет - ошибка.
					return false;

				numbers = 0;
				points++;
				delete[]buff; // Освобождаем буфер.
				buff = new char[3]; // Выделяем новую память для буфера.
			}
			else return false;
	}

	if (points != 3)
		// Если количество точек в IP-адресе не 3, это ошибка.
		return false;

	if (numbers == 0 || numbers > 3)
		return false;

	return true;
}

// Функция для преобразования строки IP-адреса в беззнаковое целое число.
unsigned long CharToLong(char* ip_)
{
	unsigned long out = 0; // Число для IP-адреса.
	char* buff = new char[3]; // Буфер для хранения одного октета.

	for (int i = 0, j = 0, k = 0; ip_[i] != '\0'; i++, j++)
	{
		if (ip_[i] != '.') // Если не точка.
			buff[j] = ip_[i]; // Записываем символ в буфер.

		if (ip_[i] == '.' || ip_[i + 1] == '\0')
		{
			// Если следующий октет или последний.
			out <<= 8; // Сдвигаем число на 8 бит.

			if (atoi(buff) > 255)
				return NULL; // Если октет больше 255, это ошибка.

			out += (unsigned long)atoi(buff); // Преобразуем и добавляем к числу IP-адреса.

			k++;
			j = -1;
			delete[]buff; // Освобождаем буфер.
			buff = new char[3]; // Выделяем новую память для буфера.
		}
	}
	return out;
}

// Функция для проверки корректности маски подсети.
// Функция для проверки корректности маски подсети.
bool CheckMask(unsigned long mask)
{
	if (mask == 0)
		return false; // Если маска равна нулю, считаем её некорректной и возвращаем false.

	unsigned long maskTest = 1 << 31; // Создаем маску для проверки битов.

	for (int i = 0; i < 32; i++) // Проходим через 32 бита маски.
	{
		if (!(mask & maskTest)) // Если текущий бит равен 0 (бит в маске сброшен).
		{
			for (int j = i + 1; j < 32; j++) // Проверяем оставшиеся биты.
			{
				mask <<= 1; // Сдвигаем маску на 1 бит влево.
				if (mask & maskTest) // Если следующий бит установлен (равен 1).
					return false; // Это означает, что маска некорректна, и возвращаем false.
			}
		}
		mask <<= 1; // Сдвигаем маску на 1 бит влево для проверки следующего бита.
	}

	return true; // Если маска соответствует стандартам CIDR, то она считается корректной и возвращаем true.
}


// Функция для преобразования 32-битного числа в строку IP-адреса и вывода на экран.
// Функция для преобразования 32-битного числа в строку IP-адреса и вывода на экран.
void WriteLongToChar(unsigned long ip)
{
	unsigned long oktet[4]; // Создаем массив для четырех октетов.
	// Преобразование 32-битного числа IP-адреса в октеты:
	oktet[0] = ip>>24; // Получаем самый старший октет путем сдвига вправо на 24 бита.
	oktet[1] = (ip<<8)>>24; // Получаем следующий октет путем сдвига влево на 8 бит и затем вправо на 24 бита.
	oktet[2] = (ip<<16)>>24; // Получаем третий октет путем сдвига влево на 16 бит и затем вправо на 24 бита.
	oktet[3] = (ip<<24)>>24; // Получаем самый младший октет путем сдвига влево на 24 бита и затем вправо на 24 бита.

	// Выводим октеты на экран в формате "x.x.x.x":
	cout << oktet[0] << "." << oktet[1] << "." << oktet[2] << "." << oktet[3] << "\n";
}


int main()
{
	setlocale(LC_ALL, "Russian"); // Установка локали для вывода сообщений на русском языке.

	unsigned long ip, mask, host, subnet, broadcast; // Объявление переменных для IP-адреса, маски, хоста, сети и broadcast - адреса.
	char* ip_, * mask_; // Объявление указателей на строки для ввода IP-адреса и маски.
	bool flag = true; // Флаг для проверки корректности ввода.

	ip_ = new char[16]; // Выделение памяти для ввода IP-адреса.
	mask_ = new char[16]; // Выделение памяти для ввода маски.

	do
	{
		if (!flag) cout << "\nНеверно введён адрес!\n" << endl; // Вывод сообщения об ошибке, если введен некорректный IP-адрес.
		cout << "введите IP - адрес: \n> ";
		cin >> ip_; // Ввод IP-адреса.
	} while (!(flag = CheckAddress(ip_))); // Повторяем ввод, пока IP-адрес не будет корректным. Функция CheckAddress() выполняет проверку.

	ip = CharToLong(ip_); // Преобразование введенного IP-адреса в числовой формат.
	flag = true; // Сброс флага.

	do
	{
		if (!flag)
			cout << "\nНеправильная маска!\n" << endl; // Вывод сообщения об ошибке, если введена некорректная маска.
		flag = true;
		do
		{
			if (!flag)
				cout << "\nНеверно введена маска!\n" << endl; // Вывод сообщения об ошибке, если введена некорректная маска.
			cout << "введите маску подсети: \n> ";
			cin >> mask_; // Ввод маски подсети.
		} while (!(flag = CheckAddress(mask_))); // Повторяем ввод маски, пока она не будет корректной. Функция CheckAddress() выполняет проверку.
		mask = CharToLong(mask_); // Преобразование введенной маски в числовой формат.
	} while (!(flag = CheckMask(mask))); // Повторяем ввод маски, пока она не будет корректной. Функция CheckMask() выполняет проверку.

	subnet = ip & mask; // Вычисление ID подсети.
	host = ip & ~mask; // Вычисление ID хоста.
	broadcast = ip & mask | ~mask; // Вычисление broadcast-адреса.

	cout << "ID подсети:\t\t";
	WriteLongToChar(subnet); // Вывод ID подсети.

	cout << "ID хоста:\t\t";
	WriteLongToChar(host); // Вывод ID хоста.

	cout << "Broadcast адрес:\t";
	WriteLongToChar(broadcast); // Вывод broadcast-адреса.

	return 0; // Завершение программы.
}